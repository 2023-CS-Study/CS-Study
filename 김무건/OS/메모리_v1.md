# 메모리 계층

![image](https://user-images.githubusercontent.com/103854287/222947680-36973560-3250-45b7-90f8-666c461ee0a4.png)

| 레지스터 | cpu안에 있는 작은 메모리 ,휘발성 , 속도 가장 빠름 , 기억 용량이 가장 적다 |
| --- | --- |
| 캐시 | L1,L2캐시를 의미한다 , 휘발성 , 속도가 빠름 , 기억 용량이 적다 |
| 주기억장치 | RAM을 가리킨다. 휘발성 , 속도 보통 , 기억 용량이 보통 |
| 보조기억장치 | HDD , SDD를 일컬으며 비휘발성 , 속도 낮음 , 기억 용량이 많다. |

### 1. 캐시

- 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 **병목 현상을 줄이기 위한 메모리**

→ 데이터를 접근하는 시간이 오래 걸리는 경우를 해결

> 지역성 원리
> 
1. 시간 지역성
- 데이터나 명령어가 한 번 참조된 이후에 일정 기간 동안 다시 참조될 가능성이 높다.

1. 공간 지역성
- 데이터나 명령어가 참조된 이후에 대항 데이터와 인전합 데이터가 참조 가능성이 높다.

### 캐시히트와 캐시미스

- 캐시에서 원하는 데이터를 찾았다면 캐시히트라고 하며, 해당 데이터가 캐시에 없다면 주 메모리로 가서 데이터를 찾아오는 것을 캐시미스

- 캐시히트 : 레디스로부터 데이터를 읽어온다.
- 키시미스 : 메인 DB로부터 데이터를 가져온다.

# 메모리 관리

> 가상 메모리
> 
- 실제 물리 메모리 개념을 논리 메모리 개념으로 분리 → 한정적인 메모리 공간을 사용자에게 더 많은 메모리를 제공하기 위해 가상 주소를 사용한다.

<aside>
💡 **TLB** : 메모리와 CPU 사이에 있는  주소 변환을 위한 캐시. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층이다.

</aside>

![image](https://user-images.githubusercontent.com/103854287/222947695-7d9069fd-9279-4ea5-8b91-4367d7e8eda0.png)

### 가상 메모리의 필요

---

1. **물리 메모리의 한계**
- 모든 프로그램 코드를 물리 메모리에 올릴 수가 없다.
- 그렇다고, 프로그램을 교체하면서 올리면 메모리 교체 성능 문제가 발생한다.

1. **가상 메모리의 장점**
- 프로그램 용량이 실제 물리 메모리보다 커도 된다.
- 전체 프로그램이 물리 메모리에 올라와 있지 않아도 된다.
- 더 많은 프로그램을 동시에 실행할 수 있다.
    - 응답 시간은 유지
    - CPU 이용률과 처리율은 증가

**→ 가상 메모리란**

메인 메모리 와 보조 기억 장치를 묶어 하나의 메모리처럼 동작하게 하여 메인 메모리의 한계를 넘는 메모리 사용을 하게 한다.

### MMU(메모리 관리 장치)

---

### MMU (Memory Management Unit, 메모리 관리 장치)

- 논리 주소를 물리주소로 변환해 준다.
- 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해주는 하드웨어임

메모리의 공간이 한정적이기 때문에, 사용자에게 더 많은 메모리를 제공하기 위해 '가상 주소'라는 개념이 등장 (가상 주소는 프로그램 상에서 사용자가 보는 주소 공간이라고 보면 됨)

이 가상 주소에서 실제 데이터가 담겨 있는 곳에 접근하기 위해선 빠른 주소 변환이 필요한데, 이를 MMU가 도와주는 것

즉, **MMU의 역할**은 다음과 같다고 말할 수 있다.

1. MMU가 지원되지 않으면, physical address를 직접 접근해야 하기 때문에 부담이 있다.
2. MMU는 사용자가 기억장소를 일일이 할당해야 하는 불편을 없애준다.
3. 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수 있게 해준다.
4. 메인 메모리의 직접 접근은 비효율적이므로, CPU와 메인 메모리 속도를 맞추기 위해 캐시가 존재함

## 스와핑 , 페이지 폴트

> 간단한 차이 설명
> 

| 스와핑 | 페이지 폴트 |
| --- | --- |
| 프로세스가 요청한 페이지에 있고 메모리가 부족한 상황에서 발생 프로세스의 일부나 전체를 메모리에서 디스크로 이동시켜 저장한다.. | 프로세스가 요청한 페이지가 현재 메모리에 없는 경우 발생한다. 해당 페이지를 디스크에서 읽어와 메모리에 로드 |

### 스와핑 과정

---

1. 프로세스가 실행 중인 상태에서 다른 프로세스가 실행되어 메모리 공간이 부족해지는 경우, 운영 체제는 Swapping 작업을 시작합니다.

1. 운영 체제는 메모리에 있는 프로세스 중 일부나 전체를 디스크의 스왑 파일(Swap File)이라는 특수한 파일에 저장합니다. 스왑 파일은 일반적으로 하드 디스크에 저장되며, 일반적으로 가상 메모리를 사용하는 운영 체제에서는 스왑 파일의 크기를 동적으로 조정할 수 있습니다.

1. 저장된 프로세스의 메모리 공간은 다른 프로세스나 데이터가 사용할 수 있도록 해제됩니다.

1. 필요한 경우, 운영 체제는 스왑 파일에서 프로세스를 읽어와 메모리에 다시 로드합니다. 이 때, 스왑 파일에서 데이터를 읽는 I/O 작업이 필요합니다.

1. 프로세스가 메모리에 다시 로드되면 실행이 재개되며, 이전 상태에서 계속해서 실행됩니다.

### 페이지 폴트 과정

---

1. 프로세스가 요청한 페이지가 메모리에 없는 경우, CPU는 인터럽트를 발생시킵니다. 이때, 페이지 폴트 예외(Page Fault Exception)가 발생합니다.

1. 운영 체제는 페이지 폴트 예외를 처리하기 위해 해당 프로세스를 일시 중지하고, 페이지 폴트 핸들러(Page Fault Handler)를 실행합니다.

1. 페이지 폴트 핸들러는 요청한 페이지가 현재 메모리에 없는 경우, 디스크에서 해당 페이지를 읽어와 메모리에 로드합니다. 이때, 페이지 테이블(Page Table)을 사용하여 가상 주소를 물리 주소로 변환합니다.

1. 페이지가 메모리에 로드되면, 프로세스는 다시 실행됩니다. 이때, CPU는 이전에 수행되던 명령어 다음부터 실행을 재개합니다.

### 스레싱

![image](https://user-images.githubusercontent.com/103854287/222947710-76302751-7423-4dc6-a3ef-2d50636ce00f.png)

- 메모리의 페이지 폴트율이 높은 것을 의미한다 → 컴퓨터의 성능 저하

- 메모리에 너무 많은 프로세스가 동시에 올라와 스와핑이 많이 일어나는 작업 페이지 폴트가 일어나면 CPU의 이용률이 낮아진다. CPU의 이용률이 낮아지게 되면 운영체제는 CPU에 작업이 없다고 생각하고 다시 프로세스를 올리게 된다. → 컴퓨터 성능 저하

- 해결 방법 : **PFF**

> PFF란
> 
- 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법

→ 상한선에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄인다.
