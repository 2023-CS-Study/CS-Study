# 메모리 할당

---

### 연속 할당

- 연속 할당은 메모리에 연속적으로 공간을 할당을 의미한다.

| 고정 분할 방식 | 가변 분할 방식 |
| --- | --- |
| 메모리를 미리 나누어 관리하는 방식 | 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용 |
| 메모리가 미리 나누어 있어 내부 단편화 | 최초적합 , 최적적합 , 최악접합 |

| 최초적합 | 위쪽이나 아래부터 시작해서 할당 가능한 메모리 공간을 찾으면서 할당 |
| --- | --- |
| 최적적합 | 프로세스의 크기 이상인 공간 중 가장 작은 공간부터 할당 |
| 최악적합 | 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당 |

---

내부 단편화

- 프로세스가 사용하는 메모리 공간에 남는 부분
- 프로세스가 요청한 양보다 더 많은 메모리를 할당할 때 발생하며, 메모리 분할 자유 공간과 프로세스가 사용하는 공간의 크기 차이를 의미한다.

![image](https://user-images.githubusercontent.com/103854287/222947768-714a15e9-5e8f-42c4-9211-9602d7c70f66.png)

외부 단편화

- 메모리 공간 중 사용하지 못하게 되는 부분
- 메모리 할당 및 해제 작업의 반복으로 작은 메모리가 중간 중간 존재할 수 있다. 이렇게 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황이다.
- 외부 단편화를 해결하기 위해 압축을 이용하여 프로세스가 사용하는 공간을 한쪽으로 몰 수 있지만, 작업 효율이 좋지는 않다.

![image](https://user-images.githubusercontent.com/103854287/222947774-a3cfffc5-29e2-4b19-85c6-b0e67144cda3.png)

---

### 불연속 할당

- 메모리를 연속적으로 할당 X
- 현재 운영체제가 사용하는 방법

> 페이징
> 
- 동일한 크기의 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
- **외부 단편화 해결**

→ 홀의 크기가 균일하지만 주소 변환이 복잡해진다.

![image](https://user-images.githubusercontent.com/103854287/222947778-e81049eb-e5c9-49c4-8e31-eb67cfdc2d0c.png)

> **세그멘테이션**
> 
- 페이지 단위가 아닌 세그먼트 단위로 나누는 방식

→ 세그먼트는 논리적인 단위로 코드,데이터,스택 ,힙등의 부분으로 나눌 수 있으며 각각의 세그먼트는 크  기다 다르다. 이때 운영 체제는 각 세그먼트의 크기와 주소 범위를 정의하고 메모리에 할당

### 장단점

- 공유와 보안 측면에서 좋다.
- **홀의 크기가 균일하지 않다.→ 내부 단편화는 해결하지만 외부 단편화의 문제가 발생한다.**

> 페이지드 세그멘테이션
> 
- 공유나 보안을 의마 단위의 세그먼트로 나누고 물리적 메모리는 페이지로 나누는 것

### 페이지 교체 알고리즘

- 메모리는 한정되어 있기 때문에 스와핑이 많이 일어난다.
- 스와핑이 많이 일어나면 성능에 문제가 생기기 때문에 페이지 교체 알고리즘을 기반으로 줄인다.

- FIFO , LPU
- LPU에서 발전한 알고리즘 → NUR
- LFU
